import React, { useState, useRef, useEffect, useCallback } from 'react';
import CameraFeed, { CameraFeedHandle } from './components/CameraFeed';
import { HUD } from './components/HUD';
import { ChatInterface } from './components/ChatInterface';
import ARWorkspace, { ARWorkspaceHandle } from './components/ARWorkspace';
import { SettingsOverlay, UXLevel, SecurityPreset } from './components/SettingsOverlay';
import { KeyboardHelp } from './components/KeyboardHelp';
import { ToastContainer, ToastType } from './components/Toast';
import { ConfirmationModal, ActionStep, Risk } from './components/ConfirmationModal';
import { SuggestionChips, Suggestion } from './components/SuggestionChips';
import { IntelligenceDashboard } from './components/IntelligenceDashboard';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { AppMode, AnalysisResult, ChatMessage, WalletState, Transaction, OSTimer, OSNotification } from './types';
import { karanaApi, WalletInfo, VisionAnalysisResponse, OracleIntentResponse } from './services/karanaService';
import { oracleAI, OracleResponse } from './services/oracleAI';
import { enhancedOracle } from './services/enhancedOracleAI';
import { systemState } from './services/systemState';
import { systemContext } from './services/systemContext';
import { intelligentRouter } from './services/intelligentRouter';
import { userProfileManager } from './services/userProfile';
import { visualIntelligence } from './services/visualIntelligence';
import { ambientIntelligence } from './services/ambientIntelligence';
import FocusMode from './components/FocusMode';
import { Eye, MessageSquare, X, AlertTriangle, Scan, Wallet, ShieldCheck, RefreshCw, Plus, Bell, Clock, Settings, HelpCircle } from 'lucide-react';

// Default wallet state before connecting to backend
const INITIAL_WALLET: WalletState = {
  balance: 0,
  did: 'Not Connected',
  transactions: []
};

const App: React.FC = () => {
  const [mode, setMode] = useState<AppMode>(AppMode.IDLE);
  const [analysis, setAnalysis] = useState<AnalysisResult | null>(null);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [wallet, setWallet] = useState<WalletState>(INITIAL_WALLET);
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pendingTx, setPendingTx] = useState<Transaction | null>(null);
  const [backendConnected, setBackendConnected] = useState(false);
  const [showRecoveryPhrase, setShowRecoveryPhrase] = useState<string[] | null>(null);
  
  // Settings State
  const [showSettings, setShowSettings] = useState(false);
  const [uxLevel, setUxLevel] = useState<UXLevel>('INTERMEDIATE');
  const [securityPreset, setSecurityPreset] = useState<SecurityPreset>('BALANCED');
  const [ephemeralMode, setEphemeralMode] = useState(false);
  
  // Timer and Notification State
  const [timers, setTimers] = useState<OSTimer[]>([]);
  const [notifications, setNotifications] = useState<OSNotification[]>([]);
  const [showTimers, setShowTimers] = useState(false);
  const [showNotifications, setShowNotifications] = useState(false);
  
  // Intelligence Dashboard State
  const [showIntelligenceDashboard, setShowIntelligenceDashboard] = useState(false);
  const [showWelcome, setShowWelcome] = useState(true);
  const [showHelp, setShowHelp] = useState(false);
  const [toasts, setToasts] = useState<Array<{ id: string; message: string; type?: ToastType }>>([]);
  
  // Visual Intelligence State
  const [focusModeActive, setFocusModeActive] = useState(true); // On by default
  const [visualIntelligenceActive, setVisualIntelligenceActive] = useState(false);
  const [ambientIntelligenceActive, setAmbientIntelligenceActive] = useState(false);
  
  // Oracle AI Confirmation & Suggestions State
  const [showConfirmation, setShowConfirmation] = useState(false);
  const [confirmationData, setConfirmationData] = useState<{
    message: string;
    steps: ActionStep[];
    totalDuration?: number;
    resources?: any;
    risks?: Risk[];
    onConfirm: () => void;
  } | null>(null);
  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);

  // Keyboard shortcuts
  const shortcuts = useKeyboardShortcuts(setMode, setShowSettings, setShowTimers, setShowNotifications);

  // Toast notification helpers
  const showToast = useCallback((message: string, type: ToastType = 'info') => {
    const id = `toast_${Date.now()}`;
    setToasts(prev => [...prev, { id, message, type }]);
  }, []);

  const dismissToast = useCallback((id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  }, []);

  useEffect(() => {
    // Check if user has seen welcome screen before
    const hasSeenWelcome = localStorage.getItem('karana_welcome_seen');
    if (!hasSeenWelcome) {
      setShowWelcome(true);
    } else {
      setShowWelcome(false);
    }
  }, []);

  const cameraRef = useRef<CameraFeedHandle>(null);
  const arWorkspaceRef = useRef<ARWorkspaceHandle>(null);

  // Connect to backend on mount
  useEffect(() => {
    const checkConnection = async () => {
      const isHealthy = await karanaApi.healthCheck();
      setBackendConnected(isHealthy);
      
      if (isHealthy) {
        // Try to get existing wallet info
        try {
          const info = await karanaApi.getWalletInfo();
          setWallet({
            balance: info.balance,
            did: info.did,
            transactions: []
          });
          // Load transaction history
          try {
            const txs = await karanaApi.getTransactions();
            setWallet(prev => ({ ...prev, transactions: txs.map(tx => ({
              id: tx.id,
              type: tx.tx_type,
              amount: tx.amount,
              recipient: tx.recipient,
              timestamp: tx.timestamp * 1000,
              status: tx.status,
              signature: tx.signature
            })) }));
          } catch {}
        } catch {
          // No wallet exists yet
        }

        // Connect WebSocket for real-time updates
        try {
          await karanaApi.connectWebSocket();
          karanaApi.subscribe('transactions');
          karanaApi.subscribe('wallet');
          
          karanaApi.onEvent('TransactionConfirmed', (data) => {
            console.log('[WS] Transaction confirmed:', data);
          });
          
          karanaApi.onEvent('WalletUpdate', (data) => {
            setWallet(prev => ({ ...prev, balance: data.balance }));
          });
        } catch (e) {
          console.warn('WebSocket connection failed, will use polling');
        }
      }
    };

    checkConnection();
    
    // Poll connection every 5 seconds if not connected
    const interval = setInterval(async () => {
      if (!backendConnected) {
        await checkConnection();
      }
    }, 5000);

    return () => {
      clearInterval(interval);
      karanaApi.disconnectWebSocket();
    };
  }, [backendConnected]);

  // Visual and Ambient Intelligence Effect
  useEffect(() => {
    if (visualIntelligenceActive) {
      const videoElement = cameraRef.current?.getVideoElement() || null;
      visualIntelligence.start(videoElement);
      showToast('üéØ Visual Intelligence activated', 'success');
    } else {
      visualIntelligence.stop();
    }
    
    return () => {
      visualIntelligence.stop();
    };
  }, [visualIntelligenceActive]);

  useEffect(() => {
    if (ambientIntelligenceActive) {
      ambientIntelligence.start();
      showToast('üß† Ambient Intelligence activated', 'success');
    } else {
      ambientIntelligence.stop();
    }
    
    return () => {
      ambientIntelligence.stop();
    };
  }, [ambientIntelligenceActive]);

  // Check for ambient notifications periodically
  useEffect(() => {
    if (!ambientIntelligenceActive) return;
    
    const notificationCheck = setInterval(() => {
      const notification = ambientIntelligence.getNextNotification();
      if (notification) {
        const osNotification: OSNotification = {
          id: notification.id,
          title: notification.message,
          body: notification.reasoning,
          priority: notification.priority === 'critical' ? 'CRITICAL' : 
                   notification.priority === 'high' ? 'HIGH' : 'NORMAL',
          category: notification.type.toUpperCase() as any,
          timestamp: notification.timestamp,
          read: false,
          actions: notification.actions
        };
        setNotifications(prev => [osNotification, ...prev]);
      }
    }, 5000); // Check every 5 seconds
    
    return () => clearInterval(notificationCheck);
  }, [ambientIntelligenceActive]);

  // Timer tick effect - update every second
  useEffect(() => {
    const timerInterval = setInterval(() => {
      setTimers(prev => prev.map(timer => {
        if (timer.state !== 'RUNNING') return timer;
        
        const newRemaining = timer.remainingMs - 1000;
        
        if (newRemaining <= 0) {
          // Timer completed - add notification
          const notification: OSNotification = {
            id: `notif_${Date.now()}`,
            title: '‚è±Ô∏è Timer Complete',
            body: timer.label || 'Your timer has finished!',
            priority: 'HIGH',
            category: 'TIMER',
            timestamp: Date.now(),
            read: false
          };
          setNotifications(prev => [notification, ...prev]);
          
          // For recurring timers, reset
          if (timer.type === 'RECURRING' && timer.recurring) {
            return {
              ...timer,
              remainingMs: timer.durationMs,
              completesAt: Date.now() + timer.durationMs
            };
          }
          
          return { ...timer, remainingMs: 0, state: 'COMPLETED' as const };
        }
        
        return { ...timer, remainingMs: newRemaining };
      }));
    }, 1000);

    return () => clearInterval(timerInterval);
  }, []);

  // Timer management functions
  const createTimer = useCallback((durationMs: number, label: string, type: 'COUNTDOWN' | 'STOPWATCH' | 'RECURRING' = 'COUNTDOWN') => {
    const timer: OSTimer = {
      id: `timer_${Date.now()}`,
      type,
      label: label || `Timer (${Math.round(durationMs / 60000)} min)`,
      durationMs,
      remainingMs: durationMs,
      state: 'RUNNING',
      createdAt: Date.now(),
      completesAt: Date.now() + durationMs
    };
    setTimers(prev => [...prev, timer]);
    return timer;
  }, []);

  const cancelTimer = useCallback((timerId: string) => {
    setTimers(prev => prev.map(t => 
      t.id === timerId ? { ...t, state: 'CANCELLED' as const } : t
    ));
  }, []);

  const pauseTimer = useCallback((timerId: string) => {
    setTimers(prev => prev.map(t => 
      t.id === timerId && t.state === 'RUNNING' ? { ...t, state: 'PAUSED' as const } : t
    ));
  }, []);

  const resumeTimer = useCallback((timerId: string) => {
    setTimers(prev => prev.map(t => 
      t.id === timerId && t.state === 'PAUSED' 
        ? { ...t, state: 'RUNNING' as const, completesAt: Date.now() + t.remainingMs } 
        : t
    ));
  }, []);

  // Notification management
  const addNotification = useCallback((title: string, body: string, priority: 'LOW' | 'NORMAL' | 'HIGH' | 'URGENT' = 'NORMAL', category: 'SYSTEM' | 'TIMER' | 'TRANSACTION' | 'GOVERNANCE' | 'SOCIAL' | 'GENERAL' = 'GENERAL') => {
    const notification: OSNotification = {
      id: `notif_${Date.now()}`,
      title,
      body,
      priority,
      category,
      timestamp: Date.now(),
      read: false
    };
    setNotifications(prev => [notification, ...prev]);
    return notification;
  }, []);

  const dismissNotification = useCallback((notifId: string) => {
    setNotifications(prev => prev.filter(n => n.id !== notifId));
  }, []);

  const markNotificationRead = useCallback((notifId: string) => {
    setNotifications(prev => prev.map(n => 
      n.id === notifId ? { ...n, read: true } : n
    ));
  }, []);

  const clearAllNotifications = useCallback(() => {
    setNotifications([]);
  }, []);

  // Create new wallet
  const handleCreateWallet = async () => {
    try {
      setIsProcessing(true);
      const result = await karanaApi.createWallet();
      setWallet({
        balance: 1000, // Initial balance from backend
        did: result.did,
        transactions: []
      });
      setShowRecoveryPhrase(result.recovery_phrase);
      showToast('Wallet created successfully! Backup your recovery phrase.', 'success');
    } catch (err: any) {
      showToast(err.message || 'Failed to create wallet', 'error');
    } finally {
      setIsProcessing(false);
    }
  };

  // Intent Handlers
  const handleAnalyze = async () => {
    if (isProcessing) return;
    setIsProcessing(true);
    setMode(AppMode.ANALYZING);
    setAnalysis(null);
    setError(null);

    try {
      await new Promise(resolve => setTimeout(resolve, 800)); // Scan animation delay
      const frame = cameraRef.current?.captureFrame();
      if (!frame) throw new Error("Could not capture camera frame");

      // Use real backend AI vision
      const result = await karanaApi.analyzeVision(frame);
      
      // Map to frontend type
      setAnalysis({
        detectedObject: result.detected_object,
        category: result.category,
        description: result.description,
        confidence: result.confidence,
        relatedTags: result.related_tags,
      });
    } catch (err: any) {
      showToast(err.message || 'Vision analysis failed', 'error');
      setMode(AppMode.IDLE);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleOracleInput = async (text: string) => {
    // 1. User Message
    const userMsg: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      text,
      timestamp: Date.now()
    };
    setChatMessages(prev => [...prev, userMsg]);
    setIsProcessing(true);

    try {
      // Update system state with current frontend state
      systemState.updateLayer('layer3_blockchain', {
        wallet: {
          exists: wallet.did !== 'Not Connected',
          did: wallet.did,
          balance: wallet.balance,
          nonce: wallet.transactions.length,
          locked: false,
          publicKey: '',
        },
        transactions: wallet.transactions.map(tx => ({
          id: tx.id,
          type: tx.type,
          from: wallet.did,
          to: tx.recipient || '',
          amount: tx.amount,
          timestamp: tx.timestamp,
          status: tx.status.toLowerCase() as 'pending' | 'confirmed' | 'failed',
          signature: tx.signature || '',
        })),
      });

      systemState.updateLayer('layer8_applications', {
        timers: timers.map(t => ({
          id: t.id,
          name: t.name,
          duration: t.duration,
          remaining: t.remaining,
          state: t.state as 'running' | 'paused' | 'expired',
          createdAt: t.createdAt,
        })),
      });

      // 2. Process with INTELLIGENT ROUTER (Pattern-based + Optional Cloud AI)
      const response = await intelligentRouter.route(text);
      
      console.log('[Oracle AI] Response:', {
        message: response.message,
        intents: response.intents.length,
        needsConfirmation: response.intents.some(i => i.requiresConfirmation),
        suggestions: response.suggestions.length
      });
      
      // 3. Oracle Response (Natural conversation with user)
      const oracleMsg: ChatMessage = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        text: response.message,
        timestamp: Date.now(),
      };
      setChatMessages(prev => [...prev, oracleMsg]);

      // 4. If needs clarification, stop here and wait for user response
      if (response.needsClarification && response.clarificationQuestion) {
        const clarificationMsg: ChatMessage = {
          id: (Date.now() + 2).toString(),
          role: 'assistant',
          text: response.clarificationQuestion,
          timestamp: Date.now(),
        };
        setChatMessages(prev => [...prev, clarificationMsg]);
        setIsProcessing(false);
        return;
      }

      // 5. If needs confirmation, show modal and wait for user
      if (response.intents.some(i => i.requiresConfirmation)) {
        setConfirmationData({
          message: `Ready to execute: ${response.intents.map(i => i.operation).join(', ')}`,
          steps: response.intents.map(intent => ({
            operation: intent.operation,
            layer: intent.layer,
            params: intent.params,
            duration: 1,
            resources: {},
            dependencies: []
          })),
          totalDuration: response.intents.length,
          resources: {},
          risks: [],
          onConfirm: async () => {
            setShowConfirmation(false);
            setIsProcessing(true);
            
            // Execute actions
            for (const intent of response.intents) {
              await executeEnhancedAction(intent);
              userProfileManager.recordAction(intent.operation, intent.params);
            }
            
            // Log activity
            if (response.intents.length > 0) {
              const primaryAction = response.intents[0];
              systemState.logActivity(primaryAction.layer, primaryAction.operation);
            }
            
            // Record success
            userProfileManager.recordSuccess(
              response.intents[0]?.operation || 'unknown',
              response.intents[0]?.confidence || 0.9
            );
            
            setIsProcessing(false);
            showToast('Actions completed successfully', 'success');
          }
        });
        setShowConfirmation(true);
        setIsProcessing(false);
        return;
      }

      // 6. Execute ALL actions (no confirmation needed)
      for (const intent of response.intents) {
        await executeEnhancedAction(intent);
        
        // Record action in user profile for learning
        userProfileManager.recordAction(intent.operation, intent.params);
      }

      // 7. Show suggestions as clickable chips
      if (response.suggestions && response.suggestions.length > 0) {
        setSuggestions(response.suggestions.map(s => ({
          text: s,
          action: s
        })));
      }

      // 8. Log activity for context
      if (response.intents.length > 0) {
        const primaryAction = response.intents[0];
        systemState.logActivity(primaryAction.layer, primaryAction.operation);
      }

      // 9. Record success/failure for learning
      if (response.intents.length > 0) {
        userProfileManager.recordSuccess(
          response.intents[0]?.operation || 'unknown',
          response.intents[0]?.confidence || 0.9
        );
      }

    } catch (err: any) {
      console.error('Oracle AI error:', err);
      
      // Record failure for learning
      if (text) {
        userProfileManager.recordFailure('oracle_process', err.message);
      }
      
      const errorMsg: ChatMessage = {
        id: (Date.now() + 2).toString(),
        role: 'assistant',
        text: `I encountered an error: ${err.message}. Could you try rephrasing that?`,
        timestamp: Date.now(),
      };
      setChatMessages(prev => [...prev, errorMsg]);
      
      showToast(err.message || 'Oracle processing failed', 'error');
    } finally {
      setIsProcessing(false);
    }
  };

  // Execute Oracle actions - bridge between AI and system
  const executeOracleAction = useCallback(async (response: OracleResponse) => {
    const { intent, data } = response;
    const intentType = intent.type;
    
    // Helper to open AR app
    const openARApp = (appType: string, options?: { url?: string }) => {
      setMode(AppMode.AR_WORKSPACE);
      setTimeout(() => {
        arWorkspaceRef.current?.spawnApp(appType as any, options);
      }, 100);
    };
    
    // Handle all intent types
    switch (intentType) {
      // ========================
      // BLOCKCHAIN / WALLET
      // ========================
      case 'TRANSFER':
        if (data?.amount && data?.recipient) {
          setPendingTx({
            id: `tx_${Date.now()}`,
            type: 'TRANSFER',
            amount: data.amount,
            recipient: data.recipient,
            timestamp: Date.now(),
            status: 'PENDING'
          });
        }
        break;
        
      case 'CHECK_BALANCE':
      case 'TRANSACTION_HISTORY':
      case 'STAKE_TOKENS':
      case 'UNSTAKE':
      case 'SHOW_DID':
      case 'BACKUP_WALLET':
        setMode(AppMode.WALLET);
        break;
        
      case 'CREATE_WALLET':
        if (!wallet.did || wallet.did === 'Not Connected') {
          await handleCreateWallet();
        }
        break;
        
      // ========================
      // GOVERNANCE
      // ========================
      case 'CREATE_PROPOSAL':
      case 'VOTE_PROPOSAL':
      case 'LIST_PROPOSALS':
      case 'PROPOSAL_STATUS':
        // Open governance view (for now, show in chat)
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: 'üèõÔ∏è Governance features coming soon. Use the Wallet panel to manage tokens.',
          timestamp: Date.now()
        }]);
        break;
        
      // ========================
      // VISION / CAMERA
      // ========================
      case 'ANALYZE_VISION':
      case 'IDENTIFY_OBJECT':
      case 'EXPLAIN_SCENE':
      case 'CAPTURE_PHOTO':
        handleAnalyze();
        break;
        
      case 'SCAN_QR':
        setMode(AppMode.ANALYZING);
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: 'üì∑ QR Scanner activated. Point camera at QR code.',
          timestamp: Date.now()
        }]);
        break;
        
      // ========================
      // TIMERS / REMINDERS
      // ========================
      case 'SET_TIMER':
      case 'SET_ALARM':
      case 'SET_REMINDER':
        if (data?.durationMs) {
          const timer = createTimer(data.durationMs, data.label || data.duration || 'Timer');
          setShowTimers(true);
          setChatMessages(prev => [...prev, {
            id: Date.now().toString(),
            role: 'system',
            text: `‚è±Ô∏è Timer "${timer.label}" started! Will complete at ${new Date(timer.completesAt!).toLocaleTimeString()}`,
            timestamp: Date.now()
          }]);
        }
        break;
        
      case 'START_STOPWATCH':
        const stopwatch = createTimer(0, 'Stopwatch', 'STOPWATCH');
        setShowTimers(true);
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: `‚è±Ô∏è Stopwatch started!`,
          timestamp: Date.now()
        }]);
        break;
        
      case 'STOP_STOPWATCH':
      case 'LAP_STOPWATCH':
        // Find active stopwatch and pause
        const activeStopwatch = timers.find(t => t.type === 'STOPWATCH' && t.state === 'RUNNING');
        if (activeStopwatch) {
          pauseTimer(activeStopwatch.id);
        }
        break;
        
      case 'LIST_TIMERS':
        setShowTimers(true);
        const activeTimers = timers.filter(t => t.state === 'RUNNING' || t.state === 'PAUSED');
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: activeTimers.length > 0 
            ? `üìã Active Timers:\n${activeTimers.map(t => `‚Ä¢ ${t.label}: ${Math.ceil(t.remainingMs / 1000)}s remaining`).join('\n')}`
            : 'üìã No active timers',
          timestamp: Date.now()
        }]);
        break;
        
      case 'CANCEL_TIMER':
        if (data?.timerId) {
          cancelTimer(data.timerId);
        } else {
          // Cancel all timers
          timers.forEach(t => {
            if (t.state === 'RUNNING') cancelTimer(t.id);
          });
        }
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: '‚èπÔ∏è Timer(s) cancelled',
          timestamp: Date.now()
        }]);
        break;
        
      // ========================
      // NOTIFICATIONS
      // ========================
      case 'SHOW_NOTIFICATIONS':
        setShowNotifications(true);
        const unread = notifications.filter(n => !n.read);
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: unread.length > 0 
            ? `üîî You have ${unread.length} unread notification(s):\n${unread.slice(0, 5).map(n => `‚Ä¢ ${n.title}: ${n.body}`).join('\n')}`
            : 'üîî No unread notifications',
          timestamp: Date.now()
        }]);
        break;
        
      case 'CLEAR_NOTIFICATIONS':
        clearAllNotifications();
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: 'üßπ All notifications cleared',
          timestamp: Date.now()
        }]);
        break;
        
      case 'DISMISS_NOTIFICATION':
        if (data?.notificationId) {
          dismissNotification(data.notificationId);
        }
        break;
        
      // ========================
      // AR APPLICATIONS
      // ========================
      case 'PLAY_VIDEO':
      case 'SEARCH_VIDEO':
        openARApp('video', { url: data?.url });
        break;

      case 'OPEN_BROWSER':
      case 'SEARCH_WEB':
      case 'OPEN_URL':
        openARApp('browser', { url: data?.url });
        break;
        
      case 'OPEN_TERMINAL':
      case 'RUN_COMMAND':
        openARApp('terminal');
        break;
        
      case 'CREATE_NOTE':
      case 'OPEN_NOTES':
      case 'SAVE_NOTE':
      case 'SEARCH_NOTES':
        openARApp('notes');
        break;
        
      case 'PLAY_MUSIC':
      case 'OPEN_MUSIC':
      case 'PAUSE_MUSIC':
      case 'NEXT_TRACK':
        openARApp('music');
        break;
        
      case 'OPEN_CALENDAR':
      case 'CREATE_EVENT':
      case 'LIST_EVENTS':
        openARApp('calendar');
        break;
        
      case 'OPEN_MAIL':
      case 'COMPOSE_MAIL':
      case 'CHECK_MAIL':
        openARApp('mail');
        break;
        
      case 'OPEN_GALLERY':
      case 'SHOW_PHOTO':
        openARApp('image');
        break;
        
      case 'CLOSE_APP':
        if (data?.appType) {
          // Close specific app type
          const windows = arWorkspaceRef.current?.getOpenWindows() || [];
          const targetWindow = windows.find(w => w.type === data.appType);
          if (targetWindow) {
            arWorkspaceRef.current?.closeApp(targetWindow.id);
          }
        }
        break;
        
      case 'CLOSE_ALL_APPS':
        arWorkspaceRef.current?.closeAllApps();
        setMode(AppMode.IDLE);
        break;
        
      case 'ARRANGE_WINDOWS':
        // Trigger layout in AR workspace
        break;
        
      // ========================
      // SYSTEM CONTROL
      // ========================
      case 'SYSTEM_STATUS':
      case 'BATTERY_STATUS':
      case 'NETWORK_STATUS':
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: `üìä System Status:\n‚Ä¢ Backend: ${backendConnected ? '‚úÖ Connected' : '‚ùå Disconnected'}\n‚Ä¢ Wallet: ${wallet.did !== 'Not Connected' ? '‚úÖ Active' : '‚ö†Ô∏è Not Created'}\n‚Ä¢ Balance: ${wallet.balance} KARA`,
          timestamp: Date.now()
        }]);
        break;
        
      case 'ADJUST_BRIGHTNESS':
      case 'TOGGLE_NIGHT_MODE':
      case 'PRIVACY_MODE':
      case 'POWER_PROFILE':
        // System settings - would interact with real hardware
        break;
        
      // ========================
      // NAVIGATION
      // ========================
      case 'NAVIGATE_TO':
      case 'SHOW_DIRECTIONS':
      case 'NEARBY_PLACES':
      case 'SHARE_LOCATION':
        setMode(AppMode.NAVIGATION);
        break;
        
      // ========================
      // HELP & INFO
      // ========================
      case 'HELP':
      case 'ABOUT_KARANA':
      case 'SETTINGS':
        // Already handled in message response
        break;
        
      // ========================
      // GENERAL / CONVERSATION
      // ========================
      case 'ANSWER_QUESTION':
      case 'EXPLAIN':
      case 'TRANSLATE':
      case 'WEB_SEARCH':
      case 'CONVERSATION':
      case 'CLARIFY':
        // Response already shown in chat
        break;
        
      case 'CONFIRM':
        // Confirmation was handled
        break;
        
      case 'CANCEL':
        // Cancelled, clear any pending states
        setPendingTx(null);
        break;
        
      // ========================
      // ANDROID APPS
      // ========================
      case 'INSTALL_APP':
        if (data?.appName) {
          const app = systemContext.findApp(data.appName);
          if (app && !app.installed) {
            // Simulate installation (instant for demo)
            systemContext.updateAppStatus(app.name, { 
              installed: true, 
              installedAt: Date.now() 
            });
            systemContext.addActivity(app.name, 'installed');
            
            setChatMessages(prev => [...prev, {
              id: Date.now().toString(),
              role: 'system',
              text: `‚úÖ ${app.name} installed successfully!`,
              timestamp: Date.now()
            }]);
            
            showToast(`${app.name} installed`, 'success');
          }
        }
        break;
        
      case 'OPEN_APP':
      case 'LAUNCH_APP':
        if (data?.appName) {
          const app = systemContext.findApp(data.appName);
          if (app) {
            if (!app.installed) {
              // Offer to install first
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'assistant',
                text: `${app.name} is not installed. Would you like me to install it first?`,
                timestamp: Date.now()
              }]);
            } else {
              // Launch the app
              systemContext.updateAppStatus(app.name, { 
                isRunning: true,
                lastUsed: Date.now()
              });
              systemContext.addActivity(app.name, 'launched');
              
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üöÄ Launching ${app.name}...`,
                timestamp: Date.now()
              }]);
              
              showToast(`Opening ${app.name}`, 'info');
            }
          }
        }
        break;
        
      case 'CLOSE_ANDROID_APP':
        if (data?.appName) {
          const app = systemContext.findApp(data.appName);
          if (app && app.isRunning) {
            systemContext.updateAppStatus(app.name, { isRunning: false });
            systemContext.addActivity(app.name, 'closed');
            
            setChatMessages(prev => [...prev, {
              id: Date.now().toString(),
              role: 'system',
              text: `‚úÖ ${app.name} closed`,
              timestamp: Date.now()
            }]);
          }
        }
        break;
        
      case 'UNINSTALL_APP':
        if (data?.appName) {
          const app = systemContext.findApp(data.appName);
          if (app && app.installed) {
            systemContext.updateAppStatus(app.name, { 
              installed: false,
              isRunning: false,
              installedAt: undefined
            });
            systemContext.addActivity(app.name, 'uninstalled');
            
            setChatMessages(prev => [...prev, {
              id: Date.now().toString(),
              role: 'system',
              text: `üóëÔ∏è ${app.name} uninstalled`,
              timestamp: Date.now()
            }]);
            
            showToast(`${app.name} removed`, 'info');
          }
        }
        break;
        
      case 'LIST_APPS':
        const installedApps = systemContext.getAllApps().filter(app => app.installed);
        const appList = installedApps.length > 0 
          ? installedApps.map(app => `‚Ä¢ ${app.name}${app.isRunning ? ' (running)' : ''}`).join('\n')
          : 'No apps installed yet.';
        
        setChatMessages(prev => [...prev, {
          id: Date.now().toString(),
          role: 'system',
          text: `üì± Installed Android Apps:\n${appList}`,
          timestamp: Date.now()
        }]);
        break;
    }
  }, [handleAnalyze, handleCreateWallet, backendConnected, wallet, createTimer, cancelTimer, pauseTimer, timers, notifications, clearAllNotifications, dismissNotification, showToast]);

  // Enhanced Action Executor - executes actions from Enhanced Oracle AI across all system layers
  const executeEnhancedAction = useCallback(async (action: any) => {
    const { layer, operation, params, requiresConfirmation } = action;

    // If requires confirmation, ask user first
    if (requiresConfirmation) {
      // For now, auto-confirm (in production, show modal)
      console.log(`Confirmation required for: ${operation}`);
    }

    try {
      switch (layer) {
        // ================================================================
        // LAYER 1: HARDWARE
        // ================================================================
        case 'HARDWARE':
          switch (operation) {
            case 'CAMERA_CAPTURE':
              await handleAnalyze();
              systemState.updateLayer('layer1_hardware', {
                camera: { active: true, mode: 'photo' as const, lastCapture: Date.now() }
              });
              break;

            case 'CAMERA_RECORD_START':
              systemState.updateLayer('layer1_hardware', {
                camera: { active: true, mode: 'video' as const }
              });
              showToast('üìπ Recording started', 'info');
              break;

            case 'CAMERA_RECORD_STOP':
              systemState.updateLayer('layer1_hardware', {
                camera: { mode: 'idle' as const }
              });
              showToast('‚èπÔ∏è Recording stopped', 'success');
              break;

            case 'CAMERA_ACTIVATE':
              systemState.updateLayer('layer1_hardware', {
                camera: { active: true, mode: 'ar' as const }
              });
              break;

            case 'DISPLAY_BRIGHTNESS':
              systemState.updateLayer('layer1_hardware', {
                display: { brightness: params.value }
              });
              showToast(`üîÜ Brightness: ${(params.value * 100).toFixed(0)}%`, 'success');
              break;

            case 'POWER_STATUS':
              const powerState = systemState.getLayer('layer1_hardware').power;
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üîã Battery: ${(powerState.batteryLevel * 100).toFixed(0)}%\n‚ö° Profile: ${powerState.powerProfile}\nüïê Runtime: ~${powerState.estimatedRuntime}min\nüå°Ô∏è Thermal: ${powerState.thermalState}`,
                timestamp: Date.now()
              }]);
              break;

            case 'POWER_SAVE_MODE':
              systemState.updateLayer('layer1_hardware', {
                power: { powerProfile: 'power-saver' as const },
                display: { brightness: 0.5, mode: 'power-saving' as const }
              });
              showToast('‚ö° Power save mode enabled', 'success');
              break;

            case 'AUDIO_VOLUME':
              systemState.updateLayer('layer1_hardware', {
                audio: { volume: params.value }
              });
              showToast(`üîä Volume: ${(params.value * 100).toFixed(0)}%`, 'success');
              break;
          }
          break;

        // ================================================================
        // LAYER 2: NETWORK
        // ================================================================
        case 'NETWORK':
          switch (operation) {
            case 'NETWORK_STATUS':
              const netState = systemState.getLayer('layer2_network');
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üåê Network Status:\n‚Ä¢ Peers: ${netState.peerCount}\n‚Ä¢ Sync: ${netState.syncStatus}\n‚Ä¢ Quality: ${netState.connectionQuality}\n‚Ä¢ Block: #${netState.latestBlock}`,
                timestamp: Date.now()
              }]);
              break;

            case 'BLOCKCHAIN_SYNC':
              showToast('üîÑ Syncing blockchain...', 'info');
              // Simulate sync
              setTimeout(() => {
                systemState.updateLayer('layer2_network', {
                  syncStatus: 'synced' as const
                });
                showToast('‚úÖ Blockchain synced', 'success');
              }, 2000);
              break;
          }
          break;

        // ================================================================
        // LAYER 3: BLOCKCHAIN
        // ================================================================
        case 'BLOCKCHAIN':
          switch (operation) {
            case 'WALLET_CREATE':
              await handleCreateWallet();
              break;

            case 'WALLET_BALANCE':
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üí∞ Balance: ${wallet.balance} KARA\nüÜî DID: ${wallet.did}`,
                timestamp: Date.now()
              }]);
              break;

            case 'WALLET_TRANSFER':
              if (params.amount > 0 && params.recipient) {
                setPendingTx({
                  id: `tx_${Date.now()}`,
                  type: 'TRANSFER',
                  amount: params.amount,
                  recipient: params.recipient,
                  timestamp: Date.now(),
                  status: 'PENDING'
                });
              }
              break;

            case 'WALLET_TRANSACTIONS':
              const txList = wallet.transactions.length > 0 
                ? wallet.transactions.slice(-5).map(tx => 
                    `‚Ä¢ ${tx.type}: ${tx.amount} KARA ‚Üí ${tx.recipient?.substring(0, 12)}... (${new Date(tx.timestamp).toLocaleString()})`
                  ).join('\n')
                : 'No transactions yet.';
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üìú Recent Transactions:\n${txList}`,
                timestamp: Date.now()
              }]);
              break;
          }
          break;

        // ================================================================
        // LAYER 5: INTELLIGENCE
        // ================================================================
        case 'INTELLIGENCE':
          switch (operation) {
            case 'VISION_ANALYZE':
              await handleAnalyze();
              break;
          }
          break;

        // ================================================================
        // LAYER 7: INTERFACE
        // ================================================================
        case 'INTERFACE':
          switch (operation) {
            case 'HUD_HIDE':
              systemState.updateLayer('layer7_interface', {
                hud: { visible: false }
              });
              showToast('üôà HUD hidden', 'info');
              break;

            case 'HUD_SHOW':
              systemState.updateLayer('layer7_interface', {
                hud: { visible: true }
              });
              showToast('üëÄ HUD visible', 'info');
              break;

            case 'GESTURE_ENABLE':
              systemState.updateLayer('layer7_interface', {
                gesture: { enabled: true, tracking: true }
              });
              showToast('üëã Gesture tracking enabled', 'success');
              break;

            case 'GESTURE_DISABLE':
              systemState.updateLayer('layer7_interface', {
                gesture: { enabled: false, tracking: false }
              });
              showToast('‚úã Gesture tracking disabled', 'info');
              break;

            case 'GAZE_ENABLE':
              systemState.updateLayer('layer7_interface', {
                gaze: { enabled: true, tracking: true }
              });
              showToast('üëÅÔ∏è Gaze tracking enabled', 'success');
              break;

            case 'GAZE_DISABLE':
              systemState.updateLayer('layer7_interface', {
                gaze: { enabled: false, tracking: false }
              });
              showToast('üëÅÔ∏è Gaze tracking disabled', 'info');
              break;

            case 'AR_MODE_ENABLE':
              setMode(AppMode.AR_WORKSPACE);
              systemState.updateLayer('layer7_interface', {
                arMode: true
              });
              showToast('ü•Ω AR mode activated', 'success');
              break;

            case 'AR_MODE_DISABLE':
              setMode(AppMode.IDLE);
              systemState.updateLayer('layer7_interface', {
                arMode: false
              });
              showToast('ü•Ω AR mode deactivated', 'info');
              break;
          }
          break;

        // ================================================================
        // LAYER 8: APPLICATIONS
        // ================================================================
        case 'APPLICATIONS':
          switch (operation) {
            case 'TIMER_CREATE':
              if (params.durationMs > 0) {
                createTimer('Timer', params.durationMs);
              }
              break;

            case 'TIMER_LIST':
              const timerList = timers.length > 0
                ? timers.map(t => `‚Ä¢ ${t.name}: ${Math.floor(t.remaining / 1000)}s (${t.state})`).join('\n')
                : 'No active timers.';
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `‚è±Ô∏è Timers:\n${timerList}`,
                timestamp: Date.now()
              }]);
              break;

            case 'TIMER_CANCEL':
              if (timers.length > 0) {
                cancelTimer(timers[0].id);
              }
              break;

            case 'NAVIGATION_START':
              setMode(AppMode.NAVIGATION);
              systemState.updateLayer('layer8_applications', {
                navigation: { active: true, destination: { name: params.destination, coordinates: { lat: 0, lng: 0 } } }
              });
              showToast(`üó∫Ô∏è Navigating to ${params.destination}`, 'info');
              break;

            case 'SETTINGS_OPEN':
              setShowSettings(true);
              break;

            case 'WELLNESS_STATUS':
              const wellness = systemState.getLayer('layer8_applications').wellness;
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üíö Wellness:\n‚Ä¢ Usage: ${wellness.usageTime}min today\n‚Ä¢ Eye Strain: ${(wellness.eyeStrain * 100).toFixed(0)}%\n‚Ä¢ Posture: ${(wellness.posture * 100).toFixed(0)}%\n‚Ä¢ Breaks: ${wellness.breaks}`,
                timestamp: Date.now()
              }]);
              break;

            case 'ANDROID_INSTALL':
              const appToInstall = systemContext.findApp(params.appName);
              if (appToInstall && !appToInstall.installed) {
                systemContext.updateAppStatus(appToInstall.name, { 
                  installed: true, 
                  installedAt: Date.now() 
                });
                systemContext.addActivity(appToInstall.name, 'installed');
                showToast(`‚úÖ ${appToInstall.name} installed`, 'success');
              }
              break;

            case 'ANDROID_OPEN':
              const appToOpen = systemContext.findApp(params.appName);
              if (appToOpen) {
                if (!appToOpen.installed) {
                  setChatMessages(prev => [...prev, {
                    id: Date.now().toString(),
                    role: 'assistant',
                    text: `${appToOpen.name} is not installed. Would you like me to install it first?`,
                    timestamp: Date.now()
                  }]);
                } else {
                  systemContext.updateAppStatus(appToOpen.name, { 
                    isRunning: true,
                    lastUsed: Date.now()
                  });
                  systemContext.addActivity(appToOpen.name, 'launched');
                  showToast(`üöÄ ${appToOpen.name} launched`, 'success');
                }
              }
              break;

            case 'ANDROID_CLOSE':
              const appToClose = systemContext.findApp(params.appName);
              if (appToClose && appToClose.isRunning) {
                systemContext.updateAppStatus(appToClose.name, { isRunning: false });
                systemContext.addActivity(appToClose.name, 'closed');
                showToast(`‚úÖ ${appToClose.name} closed`, 'info');
              }
              break;
          }
          break;

        // ================================================================
        // LAYER 9: SYSTEM SERVICES
        // ================================================================
        case 'SYSTEM_SERVICES':
          switch (operation) {
            case 'OTA_CHECK':
              const otaState = systemState.getLayer('layer9_services').ota;
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: otaState.updateAvailable 
                  ? `üì¶ Update available: v${otaState.version} (${(otaState.size! / 1024 / 1024).toFixed(1)}MB)`
                  : '‚úÖ System is up to date',
                timestamp: Date.now()
              }]);
              break;

            case 'OTA_INSTALL':
              showToast('üì• Downloading update...', 'info');
              // Simulate download
              systemState.updateLayer('layer9_services', {
                ota: { downloading: true, progress: 0 }
              });
              break;

            case 'SECURITY_MODE':
              systemState.updateLayer('layer9_services', {
                security: { mode: params.mode as any }
              });
              showToast(`üîí Security mode: ${params.mode}`, 'success');
              if (params.mode === 'paranoid') {
                setEphemeralMode(true);
                setSecurityPreset('MAXIMUM_PRIVACY');
              }
              break;

            case 'SECURITY_STATUS':
              const secState = systemState.getLayer('layer9_services').security;
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üîí Security:\n‚Ä¢ Mode: ${secState.mode}\n‚Ä¢ Biometrics: ${secState.biometricsEnabled ? 'enabled' : 'disabled'}\n‚Ä¢ Encryption: ${secState.encryptionActive ? 'active' : 'inactive'}`,
                timestamp: Date.now()
              }]);
              break;

            case 'DIAGNOSTICS_RUN':
              showToast('üîç Running diagnostics...', 'info');
              // Simulate diagnostic run
              setTimeout(() => {
                const diag = systemState.getLayer('layer9_services').diagnostics;
                setChatMessages(prev => [...prev, {
                  id: Date.now().toString(),
                  role: 'system',
                  text: `üè• Diagnostics Complete:\n‚Ä¢ Health Score: ${(diag.healthScore * 100).toFixed(0)}%\n‚Ä¢ CPU: ${(diag.metrics.cpu * 100).toFixed(0)}%\n‚Ä¢ Memory: ${(diag.metrics.memory * 100).toFixed(0)}%\n‚Ä¢ Temp: ${diag.metrics.temperature}¬∞C\n‚Ä¢ Issues: ${diag.issues.length}`,
                  timestamp: Date.now()
                }]);
                showToast('‚úÖ Diagnostics complete', 'success');
              }, 2000);
              break;

            case 'DIAGNOSTICS_STATUS':
              const diagState = systemState.getLayer('layer9_services').diagnostics;
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üè• System Health: ${(diagState.healthScore * 100).toFixed(0)}%\n${diagState.issues.length > 0 ? '‚ö†Ô∏è Issues: ' + diagState.issues.length : '‚úÖ No issues detected'}`,
                timestamp: Date.now()
              }]);
              break;
          }
          break;

        // ================================================================
        // SPATIAL (AR/ANCHORS)
        // ================================================================
        case 'SPATIAL':
          switch (operation) {
            case 'ANCHOR_CREATE':
              const newAnchor = {
                id: `anchor_${Date.now()}`,
                position: { x: 0, y: 0, z: -2 },
                rotation: { x: 0, y: 0, z: 0, w: 1 },
                roomId: 'current',
                persistent: true,
                visualSignature: '',
                createdAt: Date.now()
              };
              systemState.updateLayer('spatial', {
                anchors: [...systemState.getLayer('spatial').anchors, newAnchor]
              });
              showToast('üìç AR anchor created', 'success');
              break;

            case 'ANCHOR_LIST':
              const anchors = systemState.getLayer('spatial').anchors;
              const anchorList = anchors.length > 0
                ? anchors.map(a => `‚Ä¢ Anchor ${a.id.substring(7, 13)}`).join('\n')
                : 'No anchors yet.';
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `üìç AR Anchors:\n${anchorList}`,
                timestamp: Date.now()
              }]);
              break;

            case 'TAB_OPEN':
              setMode(AppMode.AR_WORKSPACE);
              showToast('ü™ü AR tab opened', 'success');
              break;

            case 'TAB_LIST':
              const tabs = systemState.getLayer('spatial').tabs;
              const tabList = tabs.length > 0
                ? tabs.map(t => `‚Ä¢ ${t.type} (${t.visible ? 'visible' : 'hidden'})`).join('\n')
                : 'No AR tabs open.';
              setChatMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'system',
                text: `ü™ü AR Tabs:\n${tabList}`,
                timestamp: Date.now()
              }]);
              break;
          }
          break;

        // ================================================================
        // CONVERSATION (General AI responses)
        // ================================================================
        case 'CONVERSATION':
          // Already handled by Oracle response message
          break;
      }
    } catch (err: any) {
      console.error(`Error executing ${operation}:`, err);
      showToast(`Failed to execute ${operation}`, 'error');
    }
  }, [handleAnalyze, handleCreateWallet, wallet, timers, createTimer, cancelTimer, setMode, setShowSettings, setEphemeralMode, setSecurityPreset, showToast, setPendingTx]);

  const confirmTransaction = async () => {
    if (!pendingTx) return;
    
    setIsProcessing(true);
    try {
      // Real Ed25519 signing via backend
      const signedTx = await karanaApi.signTransaction(
        'TRANSFER',
        pendingTx.recipient,
        pendingTx.amount
      );
      
      // Update wallet state
      setWallet(prev => ({
        ...prev,
        balance: prev.balance - pendingTx.amount,
        transactions: [{
          id: signedTx.tx_hash,
          type: 'TRANSFER',
          amount: pendingTx.amount,
          recipient: pendingTx.recipient,
          timestamp: signedTx.timestamp * 1000,
          status: 'CONFIRMED',
          signature: signedTx.signature
        }, ...prev.transactions]
      }));
      
      setChatMessages(prev => [...prev, {
        id: Date.now().toString(),
        role: 'system',
        text: `??? Transaction Signed with Ed25519 (${signedTx.signature.slice(0, 16)}...). Hash: ${signedTx.tx_hash.slice(0, 12)}...`,
        timestamp: Date.now()
      }]);

      setPendingTx(null);
      showToast('Transaction confirmed successfully!', 'success');
    } catch (err: any) {
      showToast(err.message || 'Transaction signing failed', 'error');
    } finally {
      setIsProcessing(false);
    }
  };

  const toggleMode = (targetMode: AppMode) => {
    if (mode === targetMode) {
      setMode(AppMode.IDLE);
    } else {
      setMode(targetMode);
      if (targetMode === AppMode.ANALYZING) {
        handleAnalyze();
      }
    }
  };

  return (
    <div className="relative w-screen h-screen bg-black text-white overflow-hidden font-sans">
      <CameraFeed active={true} ref={cameraRef} />

      {/* Welcome / Onboarding Modal */}
      {showWelcome && (
        <div className="absolute inset-0 z-[60] flex items-center justify-center bg-black/90 backdrop-blur-md animate-in fade-in duration-500">
          <div className="max-w-2xl w-full bg-slate-900 border border-cyan-500/50 rounded-2xl p-8 shadow-[0_0_100px_rgba(6,182,212,0.2)]">
            <div className="flex flex-col items-center text-center gap-6">
              <div className="w-20 h-20 rounded-full bg-cyan-900/30 border border-cyan-400 flex items-center justify-center animate-pulse">
                <Scan size={40} className="text-cyan-400" />
              </div>
              
              <div>
                <h1 className="text-4xl font-bold text-white font-rajdhani tracking-wider mb-2">WELCOME TO KARANA OS</h1>
                <p className="text-cyan-400 font-mono text-sm">SPATIAL COMPUTING // PRIVACY FIRST // AI NATIVE</p>
              </div>

              <div className="grid grid-cols-3 gap-4 w-full mt-4">
                <div className="bg-slate-800/50 p-4 rounded-xl border border-white/5">
                  <Eye className="text-amber-400 mb-2 mx-auto" size={24} />
                  <h3 className="font-bold text-white mb-1">Vision</h3>
                  <p className="text-xs text-slate-400">Real-time object analysis and scene understanding.</p>
                </div>
                <div className="bg-slate-800/50 p-4 rounded-xl border border-white/5">
                  <ShieldCheck className="text-emerald-400 mb-2 mx-auto" size={24} />
                  <h3 className="font-bold text-white mb-1">Privacy</h3>
                  <p className="text-xs text-slate-400">Local-first processing. You own your data.</p>
                </div>
                <div className="bg-slate-800/50 p-4 rounded-xl border border-white/5">
                  <MessageSquare className="text-purple-400 mb-2 mx-auto" size={24} />
                  <h3 className="font-bold text-white mb-1">Oracle</h3>
                  <p className="text-xs text-slate-400">Natural language intent system for OS control.</p>
                </div>
              </div>

              <button 
                onClick={() => {
                  localStorage.setItem('karana_welcome_seen', 'true');
                  setShowWelcome(false);
                }}
                className="mt-4 px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition-all hover:scale-105 shadow-lg shadow-cyan-900/50"
              >
                INITIALIZE SYSTEM
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Connection Status Banner */}
      {!backendConnected && (
        <div className="absolute top-0 left-0 right-0 z-50 bg-red-900/80 text-red-100 text-center py-2 text-sm flex items-center justify-center gap-2">
          <RefreshCw className="animate-spin" size={14} />
          <span>Connecting to K??ra???a OS Backend...</span>
          <span className="text-xs opacity-60">Make sure cargo run --bin karana_api_server is running</span>
        </div>
      )}

      {/* Settings Overlay */}
      <SettingsOverlay 
        isOpen={showSettings} 
        onClose={() => setShowSettings(false)}
        uxLevel={uxLevel}
        setUxLevel={setUxLevel}
        securityPreset={securityPreset}
        setSecurityPreset={setSecurityPreset}
        ephemeralMode={ephemeralMode}
        setEphemeralMode={setEphemeralMode}
      />

      {/* Keyboard Help Overlay */}
      <KeyboardHelp
        isOpen={showHelp}
        onClose={() => setShowHelp(false)}
        shortcuts={shortcuts}
      />

      <HUD 
        mode={mode} 
        wallet={wallet} 
        ephemeralMode={ephemeralMode}
        onShowDashboard={() => setShowIntelligenceDashboard(true)}
      >
        
        {/* === IDLE MODE (HOME SCREEN) === */}
        {mode === AppMode.IDLE && (
          <div className="flex flex-col items-center gap-6 animate-fade-in absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
            <div className="flex gap-4">
              <button 
                onClick={() => setMode(AppMode.ANALYZING)}
                className="glass-panel p-4 hover:bg-cyan-900/30 transition-all group flex flex-col items-center gap-2 w-32"
              >
                <Scan size={32} className="text-cyan-400 group-hover:scale-110 transition-transform" />
                <span className="text-xs font-bold tracking-widest text-cyan-200">ANALYZE</span>
              </button>
              
              <button 
                onClick={() => setMode(AppMode.ORACLE)}
                className="glass-panel p-4 hover:bg-purple-900/30 transition-all group flex flex-col items-center gap-2 w-32"
              >
                <MessageSquare size={32} className="text-purple-400 group-hover:scale-110 transition-transform" />
                <span className="text-xs font-bold tracking-widest text-purple-200">ORACLE</span>
              </button>

              <button 
                onClick={() => setMode(AppMode.AR_WORKSPACE)}
                className="glass-panel p-4 hover:bg-emerald-900/30 transition-all group flex flex-col items-center gap-2 w-32"
              >
                <span className="text-emerald-400 group-hover:scale-110 transition-transform">ü•Ω</span>
                <span className="text-xs font-bold tracking-widest text-emerald-200">AR SPACE</span>
              </button>
            </div>
            
            <div className="flex gap-4">
              <button 
                onClick={() => setShowSettings(true)}
                className="glass-panel px-6 py-2 hover:bg-slate-800/50 transition-all flex items-center gap-2"
              >
                <Settings size={16} className="text-slate-400" />
                <span className="text-xs font-bold tracking-widest text-slate-300">SYSTEM</span>
              </button>
              
              <button 
                onClick={() => setShowHelp(true)}
                className="glass-panel px-6 py-2 hover:bg-slate-800/50 transition-all flex items-center gap-2"
              >
                <HelpCircle size={16} className="text-slate-400" />
                <span className="text-xs font-bold tracking-widest text-slate-300">HELP</span>
              </button>
            </div>
          </div>
        )}

        {/* === ANALYSIS MODE === */}
        {mode === AppMode.ANALYZING && (
          <div className="relative z-20 w-full max-w-lg mx-auto flex flex-col items-center">
            {isProcessing && !analysis && (
              <div className="flex flex-col items-center gap-4">
                <div className="relative w-24 h-24">
                  <div className="absolute inset-0 border-4 border-amber-400/30 rounded-full animate-ping"></div>
                  <div className="absolute inset-0 border-4 border-t-amber-400 rounded-full animate-spin"></div>
                  <Scan className="absolute inset-0 m-auto text-amber-400 animate-pulse" size={32} />
                </div>
                <div className="hud-font text-amber-400 tracking-widest text-lg animate-pulse">VISION LAYER ANALYZING...</div>
              </div>
            )}

            {analysis && (
              <div className="glass-panel p-6 rounded-xl border-amber-500/50 text-left animate-in fade-in slide-in-from-bottom-8 duration-500 w-full">
                <div className="flex justify-between items-start mb-4 border-b border-amber-500/30 pb-2">
                   <div>
                     <h2 className="text-2xl font-bold text-amber-400 uppercase tracking-widest">{analysis.detectedObject}</h2>
                     <span className="text-xs text-amber-200/70 font-mono uppercase">{analysis.category}</span>
                   </div>
                   <div className="text-right">
                     <div className="text-3xl font-mono text-amber-400">{analysis.confidence.toFixed(0)}%</div>
                     <div className="text-[10px] text-amber-300">CONFIDENCE</div>
                   </div>
                </div>
                <p className="text-amber-100 mb-4 leading-relaxed font-light">{analysis.description}</p>
                <div className="flex flex-wrap gap-2">
                  {analysis.relatedTags.map(tag => (
                    <span key={tag} className="px-2 py-1 bg-amber-900/40 border border-amber-500/30 rounded text-xs text-amber-300 font-mono">#{tag}</span>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* === ORACLE MODE === */}
        {mode === AppMode.ORACLE && (
          <div className="relative z-20 w-full flex justify-center items-center">
            <ChatInterface 
              messages={chatMessages} 
              onSendMessage={handleOracleInput}
              isProcessing={isProcessing}
            />
          </div>
        )}

        {/* === WALLET MODE === */}
        {mode === AppMode.WALLET && (
          <div className="glass-panel p-6 w-full max-w-md rounded-xl border-blue-400/30 animate-in fade-in zoom-in-95">
             <div className="flex items-center gap-3 mb-6 border-b border-blue-400/20 pb-4">
                <ShieldCheck className="text-blue-400" size={32} />
                <div>
                  <h2 className="text-xl font-bold text-blue-100">SOVEREIGN IDENTITY</h2>
                  <p className="text-xs font-mono text-blue-300 truncate max-w-[250px]">{wallet.did}</p>
                </div>
             </div>
             
             {wallet.did === 'Not Connected' ? (
               <div className="text-center py-8">
                 <p className="text-blue-300 mb-4">No wallet connected. Create one to get started.</p>
                 <button 
                   onClick={handleCreateWallet}
                   disabled={isProcessing || !backendConnected}
                   className="px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold flex items-center gap-2 mx-auto disabled:opacity-50"
                 >
                   <Plus size={20} />
                   Create Wallet
                 </button>
               </div>
             ) : (
               <div className="space-y-4">
                  <div className="bg-blue-900/20 p-4 rounded-lg border border-blue-500/20 text-center">
                     <div className="text-xs text-blue-300 mb-1">TOTAL BALANCE</div>
                     <div className="text-4xl font-mono font-bold text-blue-400">{wallet.balance.toLocaleString()} KARA</div>
                  </div>

                  <div className="space-y-2">
                     <h3 className="text-sm font-bold text-blue-200 uppercase tracking-wider">Recent Activity</h3>
                     {wallet.transactions.length === 0 ? (
                       <p className="text-sm text-gray-500 text-center py-4">No transactions yet</p>
                     ) : (
                       wallet.transactions.slice(0, 5).map(tx => (
                         <div key={tx.id} className="flex justify-between items-center p-3 bg-black/40 rounded border border-white/5">
                            <div className="flex items-center gap-3">
                               <div className={`p-2 rounded-full ${tx.type === 'TRANSFER' ? 'bg-red-500/20 text-red-400' : 'bg-green-500/20 text-green-400'}`}>
                                 {tx.type === 'TRANSFER' ? <Navigation2 size={12} className="rotate-45" /> : <Wallet size={12} />}
                               </div>
                               <div className="flex flex-col">
                                  <span className="text-sm font-bold text-gray-200">{tx.type}</span>
                                  <span className="text-xs text-gray-500 font-mono">To: {tx.recipient}</span>
                               </div>
                            </div>
                            <div className="text-right">
                               <div className="text-sm font-bold text-white">-{tx.amount}</div>
                               <div className={`text-[10px] ${tx.status === 'CONFIRMED' ? 'text-green-500' : 'text-yellow-500'}`}>{tx.status}</div>
                            </div>
                         </div>
                       ))
                     )}
                  </div>
               </div>
             )}
          </div>
        )}

        {/* === RECOVERY PHRASE MODAL === */}
        {showRecoveryPhrase && (
          <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm">
            <div className="glass-panel p-6 max-w-md w-full rounded-2xl border-yellow-500/50">
               <div className="flex flex-col items-center text-center gap-4">
                  <div className="w-16 h-16 rounded-full bg-yellow-900/30 border border-yellow-500 text-yellow-400 flex items-center justify-center">
                     <AlertTriangle size={32} />
                  </div>
                  <h3 className="text-xl font-bold text-white">BACKUP YOUR RECOVERY PHRASE</h3>
                  <p className="text-sm text-gray-400">Write these 24 words down and store them safely. This is the ONLY way to recover your wallet.</p>
                  <div className="w-full bg-black/60 p-4 rounded border border-yellow-500/30 grid grid-cols-3 gap-2 text-left font-mono text-sm">
                    {showRecoveryPhrase.map((word, i) => (
                      <div key={i} className="text-yellow-300">
                        <span className="text-yellow-600/70 mr-1">{i+1}.</span>{word}
                      </div>
                    ))}
                  </div>
                  <button 
                    onClick={() => setShowRecoveryPhrase(null)} 
                    className="w-full py-3 rounded-lg bg-yellow-600 hover:bg-yellow-500 text-black font-bold"
                  >
                    I've Backed Up My Phrase
                  </button>
               </div>
            </div>
          </div>
        )}

        {/* === TRANSACTION SIGNING MODAL === */}
        {pendingTx && (
          <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
            <div className="glass-panel p-6 max-w-sm w-full rounded-2xl border-emerald-500/50 shadow-[0_0_50px_rgba(16,185,129,0.2)] animate-in zoom-in-95">
               <div className="flex flex-col items-center text-center gap-4">
                  <div className="w-16 h-16 rounded-full bg-emerald-900/30 border border-emerald-500 text-emerald-400 flex items-center justify-center animate-pulse">
                     <ShieldCheck size={32} />
                  </div>
                  <h3 className="text-xl font-bold text-white">SIGN TRANSACTION</h3>
                  <div className="w-full bg-emerald-900/10 p-4 rounded border border-emerald-500/20 font-mono text-sm space-y-2">
                     <div className="flex justify-between"><span>ACTION:</span> <span className="text-emerald-300">TRANSFER</span></div>
                     <div className="flex justify-between"><span>TO:</span> <span className="text-emerald-300">{pendingTx.recipient}</span></div>
                     <div className="flex justify-between border-t border-emerald-500/20 pt-2 mt-2"><span>AMOUNT:</span> <span className="text-xl font-bold text-emerald-400">{pendingTx.amount} KARA</span></div>
                  </div>
                  <div className="flex gap-3 w-full mt-2">
                     <button onClick={() => setPendingTx(null)} className="flex-1 py-3 rounded-lg border border-red-500/50 text-red-400 hover:bg-red-900/20">CANCEL</button>
                     <button 
                       onClick={confirmTransaction} 
                       disabled={isProcessing}
                       className="flex-1 py-3 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white font-bold shadow-lg shadow-emerald-900/50 disabled:opacity-50"
                     >
                       {isProcessing ? 'SIGNING...' : 'SIGN (Ed25519)'}
                     </button>
                  </div>
               </div>
            </div>
          </div>
        )}

        {/* Toast Notifications */}
        <ToastContainer toasts={toasts} onDismiss={dismissToast} />

      </HUD>

      {/* AR Workspace Mode */}
      <ARWorkspace 
        ref={arWorkspaceRef}
        isActive={mode === AppMode.AR_WORKSPACE}
        onClose={() => setMode(AppMode.IDLE)}
      />

      {/* === TIMERS OVERLAY === */}
      {showTimers && (
        <div className="absolute top-4 right-20 z-40 w-72 animate-in slide-in-from-right-4 duration-300">
          <div className="glass-panel p-4 rounded-xl border-amber-500/30">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-bold text-amber-300 flex items-center gap-2">
                <Clock size={16} /> Active Timers
              </h3>
              <button onClick={() => setShowTimers(false)} className="text-gray-400 hover:text-white">
                <X size={16} />
              </button>
            </div>
            {timers.filter(t => t.state === 'RUNNING' || t.state === 'PAUSED').length === 0 ? (
              <p className="text-sm text-gray-500 text-center py-4">No active timers</p>
            ) : (
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {timers.filter(t => t.state === 'RUNNING' || t.state === 'PAUSED').map(timer => {
                  const mins = Math.floor(timer.remainingMs / 60000);
                  const secs = Math.floor((timer.remainingMs % 60000) / 1000);
                  const progress = timer.type !== 'STOPWATCH' 
                    ? ((timer.durationMs - timer.remainingMs) / timer.durationMs) * 100 
                    : 0;
                  
                  return (
                    <div key={timer.id} className="bg-black/40 p-3 rounded-lg border border-amber-500/20">
                      <div className="flex justify-between items-center mb-2">
                        <span className="text-sm font-medium text-amber-200">{timer.label}</span>
                        <div className="flex gap-1">
                          {timer.state === 'RUNNING' ? (
                            <button onClick={() => pauseTimer(timer.id)} className="text-yellow-400 hover:text-yellow-300 p-1">
                              ‚è∏
                            </button>
                          ) : (
                            <button onClick={() => resumeTimer(timer.id)} className="text-green-400 hover:text-green-300 p-1">
                              ‚ñ∂
                            </button>
                          )}
                          <button onClick={() => cancelTimer(timer.id)} className="text-red-400 hover:text-red-300 p-1">
                            ‚úï
                          </button>
                        </div>
                      </div>
                      <div className="text-2xl font-mono text-amber-400 text-center">
                        {String(mins).padStart(2, '0')}:{String(secs).padStart(2, '0')}
                      </div>
                      {timer.type !== 'STOPWATCH' && (
                        <div className="h-1 bg-gray-700 rounded-full mt-2 overflow-hidden">
                          <div 
                            className="h-full bg-amber-500 transition-all duration-1000"
                            style={{ width: `${progress}%` }}
                          />
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        </div>
      )}

      {/* === NOTIFICATIONS OVERLAY === */}
      {showNotifications && (
        <div className="absolute top-4 right-20 z-40 w-80 animate-in slide-in-from-right-4 duration-300">
          <div className="glass-panel p-4 rounded-xl border-purple-500/30">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-bold text-purple-300 flex items-center gap-2">
                <Bell size={16} /> Notifications
              </h3>
              <div className="flex gap-2">
                {notifications.length > 0 && (
                  <button onClick={clearAllNotifications} className="text-xs text-gray-400 hover:text-white">
                    Clear All
                  </button>
                )}
                <button onClick={() => setShowNotifications(false)} className="text-gray-400 hover:text-white">
                  <X size={16} />
                </button>
              </div>
            </div>
            {notifications.length === 0 ? (
              <p className="text-sm text-gray-500 text-center py-4">No notifications</p>
            ) : (
              <div className="space-y-2 max-h-80 overflow-y-auto">
                {notifications.slice(0, 10).map(notif => (
                  <div 
                    key={notif.id} 
                    className={`p-3 rounded-lg border ${
                      notif.read 
                        ? 'bg-black/20 border-gray-700' 
                        : notif.priority === 'URGENT' 
                          ? 'bg-red-900/30 border-red-500/50' 
                          : notif.priority === 'HIGH'
                            ? 'bg-amber-900/30 border-amber-500/50'
                            : 'bg-purple-900/20 border-purple-500/30'
                    }`}
                    onClick={() => markNotificationRead(notif.id)}
                  >
                    <div className="flex justify-between items-start">
                      <div className="flex-1">
                        <div className="text-sm font-medium text-white flex items-center gap-1">
                          {!notif.read && <span className="w-2 h-2 bg-purple-500 rounded-full" />}
                          {notif.title}
                        </div>
                        <p className="text-xs text-gray-400 mt-1">{notif.body}</p>
                        <span className="text-[10px] text-gray-600 mt-1 block">
                          {new Date(notif.timestamp).toLocaleTimeString()}
                        </span>
                      </div>
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          dismissNotification(notif.id);
                        }} 
                        className="text-gray-500 hover:text-white p-1"
                      >
                        <X size={12} />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Modern Bottom Floating Dock */}
      <div className="fixed bottom-8 left-1/2 -translate-x-1/2 z-50 pointer-events-auto">
        <div className="glass-panel px-6 py-3 flex items-center gap-4 animate-slide-up">
          <DockButton 
            icon={<Eye size={24} />} 
            label="VISION" 
            active={mode === AppMode.ANALYZING} 
            color="amber"
            onClick={() => toggleMode(AppMode.ANALYZING)} 
            labelPosition="top"
          />
          <DockButton 
            icon={<MessageSquare size={24} />} 
            label="ORACLE" 
            active={mode === AppMode.ORACLE} 
            color="purple"
            onClick={() => toggleMode(AppMode.ORACLE)} 
            labelPosition="top"
          />
          
          <div className="w-px h-8 bg-white/10 mx-2" />
          
          <DockButton 
            icon={<Wallet size={24} />} 
            label="WALLET" 
            active={mode === AppMode.WALLET} 
            color="blue"
            onClick={() => toggleMode(AppMode.WALLET)} 
            labelPosition="top"
          />
          <DockButton 
            icon={
              <div className="relative">
                <Clock size={24} />
                {timers.filter(t => t.state === 'RUNNING').length > 0 && (
                  <span className="absolute -top-1 -right-1 w-3 h-3 bg-amber-500 rounded-full animate-pulse" />
                )}
              </div>
            } 
            label="TIMERS" 
            active={showTimers} 
            color="amber"
            onClick={() => setShowTimers(!showTimers)} 
            labelPosition="top"
          />
          <DockButton 
            icon={
              <div className="relative">
                <Bell size={24} />
                {notifications.filter(n => !n.read).length > 0 && (
                  <span className="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full text-[8px] flex items-center justify-center">
                    {notifications.filter(n => !n.read).length}
                  </span>
                )}
              </div>
            } 
            label="ALERTS" 
            active={showNotifications} 
            color="purple"
            onClick={() => setShowNotifications(!showNotifications)} 
            labelPosition="top"
          />
          
          <div className="w-px h-8 bg-white/10 mx-2" />

          <DockButton 
            icon={<Settings size={24} />} 
            label="SETTINGS" 
            active={showSettings} 
            color="cyan"
            onClick={() => setShowSettings(!showSettings)} 
            labelPosition="top"
          />
        </div>
      </div>



      {/* Confirmation Modal */}
      {confirmationData && (
        <ConfirmationModal
          isOpen={showConfirmation}
          onClose={() => setShowConfirmation(false)}
          onConfirm={confirmationData.onConfirm}
          onCancel={() => {
            setShowConfirmation(false);
            setConfirmationData(null);
            showToast('Action cancelled', 'info');
          }}
          message={confirmationData.message}
          steps={confirmationData.steps}
          totalDuration={confirmationData.totalDuration}
          resources={confirmationData.resources}
          risks={confirmationData.risks}
        />
      )}

      {/* Suggestion Chips (displayed in Oracle mode) */}
      {mode === AppMode.ORACLE && suggestions.length > 0 && (
        <div className="fixed bottom-24 left-1/2 -translate-x-1/2 z-30 w-full max-w-2xl px-4">
          <SuggestionChips
            suggestions={suggestions}
            onSuggestionClick={(suggestion) => {
              handleOracleInput(suggestion.text);
              setSuggestions([]); // Clear after clicking
            }}
          />
        </div>
      )}

      {/* Focus Mode - Visual Intelligence Feedback */}
      <FocusMode isActive={focusModeActive && visualIntelligenceActive} />

      {/* Visual Intelligence Controls - Bottom Right */}
      <div className="fixed bottom-4 right-4 z-40 flex flex-col gap-2 pointer-events-auto">
        <button
          onClick={() => setVisualIntelligenceActive(!visualIntelligenceActive)}
          className={`
            px-4 py-2 rounded-lg text-sm font-medium transition-all
            ${visualIntelligenceActive 
              ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/50' 
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }
          `}
          title="Toggle Visual Intelligence"
        >
          üëÅÔ∏è {visualIntelligenceActive ? 'Visual ON' : 'Visual OFF'}
        </button>
        
        <button
          onClick={() => setAmbientIntelligenceActive(!ambientIntelligenceActive)}
          className={`
            px-4 py-2 rounded-lg text-sm font-medium transition-all
            ${ambientIntelligenceActive 
              ? 'bg-purple-500 text-white shadow-lg shadow-purple-500/50' 
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }
          `}
          title="Toggle Ambient Intelligence"
        >
          üß† {ambientIntelligenceActive ? 'Ambient ON' : 'Ambient OFF'}
        </button>
        
        <button
          onClick={() => setFocusModeActive(!focusModeActive)}
          className={`
            px-4 py-2 rounded-lg text-sm font-medium transition-all
            ${focusModeActive 
              ? 'bg-green-500 text-white shadow-lg shadow-green-500/50' 
              : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
            }
          `}
          title="Toggle Focus Mode UI"
        >
          üéØ {focusModeActive ? 'Focus ON' : 'Focus OFF'}
        </button>
      </div>

      {/* Intelligence Dashboard */}
      <IntelligenceDashboard 
        isVisible={showIntelligenceDashboard}
        onClose={() => setShowIntelligenceDashboard(false)}
      />

    </div>
  );
};

// Helper Component for Dock Buttons
const DockButton = ({ icon, label, active, color, onClick, labelPosition = 'top' }: any) => {
  return (
    <button
      onClick={onClick}
      className={`p-3 glass-button group relative ${active ? 'active scale-110' : 'opacity-80 hover:opacity-100'}`}
    >
      <div className={`${active ? 'text-white' : 'text-gray-300 group-hover:text-white'}`}>
        {icon}
      </div>
      
      {/* Label Tooltip */}
      <span className={`
        absolute -top-10 left-1/2 -translate-x-1/2 
        text-[10px] font-bold tracking-widest 
        bg-black/80 backdrop-blur-sm px-2 py-1 rounded-lg border border-white/10 
        transition-all duration-200 whitespace-nowrap
        ${active || 'group-hover:opacity-100 opacity-0 translate-y-2 group-hover:translate-y-0'}
      `}>
        {label}
      </span>
      
      {/* Active Indicator Dot */}
      {active && (
        <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-1 h-1 bg-white rounded-full shadow-[0_0_8px_rgba(255,255,255,0.8)]" />
      )}
    </button>
  );
}

export default App;
